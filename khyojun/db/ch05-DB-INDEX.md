## 인덱스

> INDEX : 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

인덱스를 이용하는 이유는 더 빨리 읽기 위해서이다. 시간 복잡도 상으로 얘기를 해보자면 O(N)의 방식이 일반적인 방식이지만, 인덱스를 활용하여 B-Tree방식을 활용하면 O(logN)만에 조회를 할 수 있다.

인덱스를 사용하는 방법은
```mysql
CREATE INDEX 인덱스 이름 ON 테이블명 (attributes)
CREATE UNIQUE INDEX 인덱스 이름 ON 테이블명 (attributes)

```

위에 1번째는 속성이 1개일 경우 2번째의 경우에는 중복 없는 유니크한 속성을 지정할 때 들어가게 하는 것이다. 

Table 생성부터 바로 인덱스를 생성하는 방법은 다음과 같다.
```mysql
CREATE TABLE PLAYER{
    .
    .
    .
    INDEX 인덱스 이름 (속성)
    
    }

```

어떤 인덱스가 있는지 확인하고 싶으면 아래 구문을 사용하면 된다.
```mysql
SHOW INDEX FROM 테이블명;
```

위에서 아까 얘기한 대로 B-Tree를 기반으로 한 인덱스를 이용하면 조회를 하는데 O(logN)안에 찾을 수 있다고 했다. 어떻게 찾는 것일까?

**Attendance**

| id  | check |
|-----|:-----:|
| 1   |  yes  |
| 2   |  yes  |   
| 3   |  yes  |
| 3   |  no   |

**INDEX(id)**

| id | ptr  |
|---|:----:|
| 1 | 주소1  |
| 2 | 주소2  |   
| 3 | 주소3  |
|3|주소4|

항상 INDEX를 선언하게 되면 해당 값을 정렬을 하게 된다고 한다. 이럴 때 Binary Search방식으로 해서 검색을 하는 것이다. 그렇게 하면 WHERE = 3 해서 찾게 되는 경우라고 치면
3번을 확인해야 할 작업을 2번만에 확인 할 수 있다.

그런데 만약 여기서 추가로 `WHERE id=3 AND CHECK=YES` 면 어떻게 해야 될까? 위 테이블을 예시로 들면 일단 id에 해당하는 값을 찾고 기존의 테이블로 다시 돌아가서 check에 대한 답을 확인해야 한다. 
이렇게 하는 것은 거의 완전히 다 탐색하는 거랑 별반 다를게 없어지는 것이다.(FULL SCAN)

그러면 여기서 INDEX를 복합 INDEX로 하여서 INDEX(id, check)로 하게 된다면?

| id | check | ptr |
|---|:-----:|:---:|
| 1 |  yes  | 주소1 |
| 2 |  yes  | 주소2 |   
| 3 |  no   | 주소4 |
|3|  yes  | 주소3 |


여기서 숫자가 아니라서 정렬이 어떻게 되어있는지는 안 보이지만 id에 대한 것은 정렬순으로 되었지만 check에 대한 것은 id 가 정렬되고 그 이후에 그 id안에서 정렬이 또 되어있기에 yes보다 no가 먼저 온것이다.
**중요한 것은 INDEX를 선언하는 순서에 따라서 정렬되는 요소도 다르기 때문에 잘 확인하고 순서를 정해야 한다.**


그래서 항상 index를 사용할 때에도 query에 알맞게 선언해야지만 query가 빠르게 처리될 수 있다. 그런데 만약 위와 같은 INDEX들이 여러 개 있는 경우에는 SELECT나 다른 작업을 할 때 어떤 INDEX를 사용해서 값을 조회를 할 지 누가 정할까?

앞 챕터에서 MySQL의 Optimizer가 뭐가 더 빠르게 조회하는지 판단해서 선택을 한다고 한다. 그렇지만 이것이 우리의 의도와는 다른 INDEX를 선택할 수 있기 때문에 EXPLAIN이라는 것을 앞에 붙여서 실행계획을 확인하고 우리가 직접 지정할 때도 있다고 한다.

지정하는 방법은 다음과 같다.
```mysql
SELECT * FROM player USE INDEX (특정 index) 특정 인덱스 사용을 권장
SELECT * FROM player FORCE INDEX (특정 index) 특정 인덱스 무조건 사용
SELECT * FROM player IGNORE INDEX (특정 index) 특정 인덱스 무시하고 선택
```


### 인덱스를 남발하면 안되는 이유

- Index에 해당하는 TABLE의 write가 발생할때마다 오버헤드가 일어남.
- 추가적인 저장 공간을 차지한다.
- 불필요한 index는 안 만드는게 좋다.

### Covering INDEX

위 말 뜻 그대로 해석하면 어떤걸 커버를 쳐주는 것인데 그게 INDEX가 커버가 될 수 있다는 것이다. 앞선 테이블 예시를 들어서 INDEX(id, check)를 한 뒤에 WHERE id = 1 AND check= yes라고 했을 때 INDEX 테이블만 참고를 하여도 바로 주소도 알기에 레코드를 조회할 수 있다.

쉽게 말하면 본래의 테이블을 참고하지 않아도 INDEX 테이블 만으로도 바로 확인할 수 있으면 이 INDEX는 Covering INDEX가 되는 것이다.


### 사실 B-Tree 말고 Hash INDEX도 있다.

B-Tree를 대부분 많이 쓰긴 하지만 Hash INDEX라는 방법도 있다. 이 친구는 (key, value)방식으로 값을 찾는데 이 친구의 시간 복잡도는 O(1)이다.

더 빠른데 왜 이 친구를 사용하지 않을까?

- rehashing(해시 테이블이 늘어나는 것)에 대한 부담
- equality 비교만 가능, range 비교는 불가능
- multicolumn index의 경우 전체 attributes에 대한 조회만 가능

### INDEX보다 FULL SCAN이 좋은 경우

- TABLE에 데이터가 조금 있을 때
- 조회하려는 데이터가 테이블의 상당 부분을 차지할 때

라고 하는 큰 기준이 있지만 사실 이것을 결정하는 친구는 Optimizer가 선택한 후 우리에게 보여준다.

### 이것 외에 부분

- order by, group by에도 index를 사용할 수 있다.
- foreign key 에서는 index가 자동으로 생성되지 않는다.(join 관련)
- 데이터가 몇 백만건 있는 테이블에서는 인덱스 생성 시 시간이 몇 분 이상 소요가 되어서 DB 성능상으로는 좋지 않다.
  - 어쩔 수 없이 이런 작업 해야되면 트래픽이 적은 시간에 진행을 하는 것이 좋다.
- SQL 명령문 동장 방식이 RDBMS마다 다르기에 Optimizer도 어떻게 판단할지도 다르다. 그렇기에 EXPLAIN을 활용하여서 실행계획을 확인하고 그에 최적화된 INDEX를 사용하는지 확인하는 것이 좋다.


## 조금 더 깊게



### INDEX의 작업

- INSERT : 새로운 데이터에 대한 인덱스 추가작업
- DELETE : 삭제하는 데이터 INDEX를 사용하지 않는 작업을 진행
- UPDATE : 기존 INDEX를 사용하지 않는다고 하고, 갱신된 데이터 INDEX를 추가한다.


### INDEX 장,단점
- 장점
  - TABLE 조회 속도가 빨라진다.
  - 시스템 부하가 적어진다.
- 단점
  - INDEX 관리를 위해 DB의 약 10퍼센트의 저장공간이 필요로 한다.
  - INDEX 관리 때문에 추가적인 작업을 해야 한다.
  - 잘못 쓰면 성능이 오히려 하락된다. 
    - INSERT,UPDATE,DELETE 가 빈번한 친구한테 사용하면 크기가 너무 커져서 성능이 저한된다.
      - UPDATE, DELETE를 많이 하면 실제 데이터가 10만개인 친구의 인덱스 테이블은 100만개가 될 수도 있다.



### 언제 INDEX를 사용하면 좋은가?

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE를 자주 사용하지 않는 친구에게 사용
- WHERE, JOIN, ORDER BY 자주 사용되는 친구에게
- 데이터 중복도가 낮은 컬럼에게

### 인덱스 자료구조
- Hash Table
  - key value 형식
- B+Tree
  - B-Tree의 발전 구조
  - 리프 노드만 인덱스와 함께 데이터를 가지고 있고 나머지 노드들은 데이터를 위한 index만 있다.
  - Linked List로 연결되어있다.
  - 데이터 노드 크기가 인덱스 노드의 크기와 같지 않다. 
  - 장점
    - 순차 검색에 용이하게 인덱스가 최적화 되어 있다.
  - 단점
    - Best Case의 경우에도 리프 노드까지 탐색을 해줘야 한다. 
  - InnoDB에서는 같은 레벨의 노드 끼리 Double Linked List방식으로 되어 있다.
  - 자식 노드 끼리는 Single Linked List로 되어 있다.

### PK가 엄청 중요하다!

왜냐하면 PK를 활용해서 MySQL에서는 레코드의 저장 위치를 결정하기 때문이다.
그래서 PK가 유사한 레코드들끼리 **묶어서 저장**을 한다 : `클러스터링`


### PK == (클러스터 인덱스)

![](pk저장방식.png)

